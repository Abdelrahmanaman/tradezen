import { betterAuth } from 'better-auth';
import { drizzleAdapter } from 'better-auth/adapters/drizzle';
import { drizzle } from 'drizzle-orm/node-postgres';
import { pgTable, timestamp, text, boolean, integer, serial, index, real, jsonb } from 'drizzle-orm/pg-core';
import { relations, sql } from 'drizzle-orm';
import { x } from '../../index.mjs';
import 'node:events';
import 'node:buffer';
import 'vinxi/lib/invariant';
import 'vinxi/lib/path';
import 'node:url';
import 'node:fs';
import '@tanstack/router-core';
import 'tiny-invariant';
import '@tanstack/start-server-core';
import '@tanstack/start-client-core';
import '@tanstack/react-router';
import 'react/jsx-runtime';
import 'react/compiler-runtime';
import 'react';
import '@radix-ui/react-slot';
import 'class-variance-authority';
import 'clsx';
import 'tailwind-merge';
import '@radix-ui/react-dialog';
import 'lucide-react';
import '@radix-ui/react-tooltip';
import 'motion/react';
import '@radix-ui/react-avatar';
import '@radix-ui/react-dropdown-menu';
import '@tanstack/react-query';
import 'next-themes';
import 'sonner';
import '@tanstack/react-query-devtools';
import '@tanstack/react-router-with-query';
import 'node:stream';
import 'isbot';
import 'react-dom/server';
import 'node:path';
import 'node:crypto';
import 'node:async_hooks';

const d = { updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().default(sql`now()`), createdAt: timestamp("created_at", { withTimezone: true }).notNull().default(sql`now()`) }, t = pgTable("user", { id: text("id").primaryKey(), name: text("name"), email: text("email").notNull().unique(), emailVerified: boolean("email_verified").notNull(), image: text("image"), userName: text("user_name").notNull().unique(), totalCoins: integer("total_coins").notNull().default(0), paypalEmail: text("paypal_email"), preferredPaymentMethod: text("preferred_payment_method"), bio: text("bio"), reputationScore: real("reputation_score").default(0), followersCount: integer("followers_count").notNull().default(0), followingCount: integer("following_count").notNull().default(0), tradeCount: integer("trade_count").notNull().default(0), ...d }), R = pgTable("session", { id: text("id").primaryKey(), expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(), token: text("token").notNull().unique(), ipAddress: text("ip_address"), userAgent: text("user_agent"), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), ...d }), D = pgTable("account", { id: text("id").primaryKey(), accountId: text("account_id").notNull(), providerId: text("provider_id").notNull(), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), accessToken: text("access_token"), refreshToken: text("refresh_token"), idToken: text("id_token"), accessTokenExpiresAt: timestamp("access_token_expires_at", { withTimezone: true }), refreshTokenExpiresAt: timestamp("refresh_token_expires_at", { withTimezone: true }), scope: text("scope"), password: text("password"), ...d }), O = pgTable("verification", { id: text("id").primaryKey(), identifier: text("identifier").notNull(), value: text("value").notNull(), expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(), ...d }), a = pgTable("games", { id: serial("id").primaryKey(), name: text("name").notNull().unique(), description: text("description"), logoUrl: text("logo_url"), isActive: boolean("is_active").default(true), sortOrder: integer("sort_order").default(0), ...d }), y = pgTable("categories", { id: serial("id").primaryKey(), gameId: integer("game_id").notNull().references(() => a.id, { onDelete: "cascade" }), name: text("name").notNull(), description: text("description"), sortOrder: integer("sort_order").default(0), ...d }, (e) => [index("idx_categories_game_id").on(e.gameId)]), _ = pgTable("rarity_types", { id: serial("id").primaryKey(), gameId: integer("game_id").notNull().references(() => a.id, { onDelete: "cascade" }), name: text("name").notNull(), displayName: text("display_name"), colorHex: text("color_hex"), sortOrder: integer("sort_order").default(0), ...d }, (e) => [index("idx_rarity_types_game_id").on(e.gameId), index("idx_rarity_types_unique").on(e.gameId, e.name)]), n = pgTable("items", { id: serial("id").primaryKey(), gameId: integer("game_id").notNull().references(() => a.id, { onDelete: "cascade" }), categoryId: integer("category_id").notNull().references(() => y.id, { onDelete: "cascade" }), name: text("name").notNull(), description: text("description"), imageUrl: text("image_url").notNull(), suggestedPrice: integer("suggested_price"), isActive: boolean("is_active").default(true), slug: text("slug").notNull().unique(), metadata: jsonb("metadata"), rarityTypeId: integer("rarity_type_id").references(() => _.id, { onDelete: "set null" }), ...d }, (e) => [index("idx_items_game_id").on(e.gameId), index("idx_items_category_id").on(e.categoryId), index("idx_items_name").on(e.name), index("idx_items_rarity_type_id").on(e.rarityTypeId)]), p = pgTable("listings", { id: serial("id").primaryKey(), sellerId: text("seller_id").notNull().references(() => t.id, { onDelete: "cascade" }), itemId: integer("item_id").notNull().references(() => n.id, { onDelete: "cascade" }), price: integer("price").notNull(), quantity: integer("quantity").default(1), age: text("age"), lookingFor: text("looking_for").array(), listingRarityId: integer("listing_rarity_id").references(() => _.id, { onDelete: "set null" }), status: text("status").notNull().default("active"), featured: boolean("featured").default(false), slug: text("slug").notNull(), expiresAt: timestamp("expires_at", { withTimezone: true }), metadata: jsonb("metadata"), ...d }, (e) => [index("idx_listings_status").on(e.status), index("idx_listings_seller_id").on(e.sellerId), index("idx_listings_item_id").on(e.itemId), index("idx_listings_listing_rarity_id").on(e.listingRarityId), index("idx_listings_featured").on(e.featured)]), g = pgTable("transactions", { id: serial("id").primaryKey(), listingId: integer("listing_id").references(() => p.id, { onDelete: "set null" }), buyerId: text("buyer_id").notNull().references(() => t.id, { onDelete: "restrict" }), sellerId: text("seller_id").notNull().references(() => t.id, { onDelete: "restrict" }), itemId: integer("item_id").notNull().references(() => n.id, { onDelete: "restrict" }), price: integer("price").notNull(), quantity: integer("quantity").notNull().default(1), transactionType: text("transaction_type").notNull(), timestamp: timestamp("timestamp").notNull().default(sql`now()`), ...d }, (e) => [index("idx_transactions_buyer_id").on(e.buyerId), index("idx_transactions_seller_id").on(e.sellerId)]), f = pgTable("trades", { id: serial("id").primaryKey(), initiatorId: text("initiator_id").notNull().references(() => t.id, { onDelete: "cascade" }), receiverId: text("receiver_id").notNull().references(() => t.id, { onDelete: "cascade" }), initiatorCoinsOffered: integer("initiator_coins_offered").default(0), receiverCoinsRequested: integer("receiver_coins_requested").default(0), status: text("status").notNull().default("pending"), message: text("message"), completedAt: timestamp("completed_at", { withTimezone: true }), ...d }, (e) => [index("idx_trades_initiator_id").on(e.initiatorId), index("idx_trades_receiver_id").on(e.receiverId), index("idx_trades_status").on(e.status)]), I = pgTable("trade_items", { id: serial("id").primaryKey(), tradeId: integer("trade_id").notNull().references(() => f.id, { onDelete: "cascade" }), itemId: integer("item_id").notNull().references(() => n.id, { onDelete: "restrict" }), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), quantity: integer("quantity").default(1), userSpecifiedRarityId: integer("user_specified_rarity_id").references(() => _.id, { onDelete: "set null" }), metadata: jsonb("metadata"), ...d }, (e) => [index("idx_trade_items_trade_id").on(e.tradeId), index("idx_trade_items_user_id").on(e.userId), index("idx_trade_items_rarity_id").on(e.userSpecifiedRarityId)]), T = pgTable("coin_purchases", { id: serial("id").primaryKey(), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), coinsAmount: integer("coins_amount").notNull(), cashAmount: real("cash_amount").notNull(), paymentMethod: text("payment_method").notNull(), paymentReference: text("payment_reference"), status: text("status").notNull().default("completed"), timestamp: timestamp("timestamp").notNull().default(sql`now()`), ...d }, (e) => [index("idx_coin_purchases_user_id").on(e.userId)]), A = pgTable("coin_cashouts", { id: serial("id").primaryKey(), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), coinsAmount: integer("coins_amount").notNull(), cashAmount: real("cash_amount").notNull(), paymentMethod: text("payment_method").notNull(), paymentDetails: text("payment_details"), status: text("status").notNull().default("pending"), timestamp: timestamp("timestamp").notNull().default(sql`now()`), processedAt: timestamp("processed_at", { withTimezone: true }), notes: text("notes"), ...d }, (e) => [index("idx_coin_cashouts_user_id").on(e.userId), index("idx_coin_cashouts_status").on(e.status)]), w = pgTable("search_history", { id: serial("id").primaryKey(), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), searchQuery: text("search_query").notNull(), gameId: integer("game_id").references(() => a.id, { onDelete: "set null" }), categoryId: integer("category_id").references(() => y.id, { onDelete: "set null" }), timestamp: timestamp("timestamp").notNull().default(sql`now()`), ...d }, (e) => [index("idx_search_history_user_id").on(e.userId)]), q = pgTable("price_history", { id: serial("id").primaryKey(), itemId: integer("item_id").notNull().references(() => n.id, { onDelete: "cascade" }), averagePrice: integer("average_price").notNull(), volume: integer("volume").notNull(), date: text("date").notNull(), ...d }, (e) => [index("idx_price_history_item_id").on(e.itemId), index("idx_price_history_date").on(e.date)]), N = pgTable("user_reviews", { id: serial("id").primaryKey(), reviewerId: text("reviewer_id").notNull().references(() => t.id, { onDelete: "cascade" }), targetUserId: text("target_user_id").notNull().references(() => t.id, { onDelete: "cascade" }), tradeId: integer("trade_id").references(() => f.id, { onDelete: "set null" }), rating: integer("rating").notNull(), comment: text("comment"), isVisible: boolean("is_visible").notNull().default(true), ...d }, (e) => [index("idx_user_reviews_reviewer_id").on(e.reviewerId), index("idx_user_reviews_target_user_id").on(e.targetUserId), index("idx_user_reviews_unique_per_trade").on(e.reviewerId, e.targetUserId, e.tradeId)]), v = pgTable("user_follows", { id: serial("id").primaryKey(), followerId: text("follower_id").notNull().references(() => t.id, { onDelete: "cascade" }), followingId: text("following_id").notNull().references(() => t.id, { onDelete: "cascade" }), ...d }, (e) => [index("idx_user_follows_unique").on(e.followerId, e.followingId), index("idx_user_follows_follower_id").on(e.followerId), index("idx_user_follows_following_id").on(e.followingId)]), U = relations(t, ({ many: e }) => ({ sessions: e(R), accounts: e(D), listings: e(p, { relationName: "seller" }), buyerTransactions: e(g, { relationName: "buyer" }), sellerTransactions: e(g, { relationName: "seller" }), initiatedTrades: e(f, { relationName: "initiator" }), receivedTrades: e(f, { relationName: "receiver" }), tradeItems: e(I), coinPurchases: e(T), coinCashouts: e(A), searchHistory: e(w), receivedReviews: e(N, { relationName: "receivedReviews" }), givenReviews: e(N, { relationName: "givenReviews" }), followers: e(v, { relationName: "followers" }), following: e(v, { relationName: "following" }) })), H = relations(R, ({ one: e }) => ({ user: e(t, { fields: [R.userId], references: [t.id] }) })), L = relations(D, ({ one: e }) => ({ user: e(t, { fields: [D.userId], references: [t.id] }) })), F = relations(N, ({ one: e }) => ({ reviewer: e(t, { fields: [N.reviewerId], references: [t.id], relationName: "givenReviews" }), targetUser: e(t, { fields: [N.targetUserId], references: [t.id], relationName: "receivedReviews" }), trade: e(f, { fields: [N.tradeId], references: [f.id] }) })), G = relations(v, ({ one: e }) => ({ follower: e(t, { fields: [v.followerId], references: [t.id], relationName: "following" }), following: e(t, { fields: [v.followingId], references: [t.id], relationName: "followers" }) })), M = relations(a, ({ many: e }) => ({ categories: e(y), items: e(n), rarityTypes: e(_) })), j = relations(y, ({ one: e, many: m }) => ({ game: e(a, { fields: [y.gameId], references: [a.id] }), items: m(n) })), B = relations(_, ({ one: e, many: m }) => ({ game: e(a, { fields: [_.gameId], references: [a.id] }), listings: m(p, { relationName: "listingRarity" }) })), V = relations(n, ({ one: e, many: m }) => ({ game: e(a, { fields: [n.gameId], references: [a.id] }), category: e(y, { fields: [n.categoryId], references: [y.id] }), listings: m(p), transactions: m(g), priceHistory: m(q), rarityType: e(_, { fields: [n.rarityTypeId], references: [_.id] }) })), Q = relations(p, ({ one: e, many: m }) => ({ seller: e(t, { fields: [p.sellerId], references: [t.id], relationName: "seller" }), item: e(n, { fields: [p.itemId], references: [n.id] }), listingRarity: e(_, { fields: [p.listingRarityId], references: [_.id], relationName: "listingRarity" }), transactions: m(g) })), $ = relations(g, ({ one: e }) => ({ buyer: e(t, { fields: [g.buyerId], references: [t.id], relationName: "buyer" }), seller: e(t, { fields: [g.sellerId], references: [t.id], relationName: "seller" }), listing: e(p, { fields: [g.listingId], references: [p.id] }), item: e(n, { fields: [g.itemId], references: [n.id] }) })), J = relations(f, ({ one: e, many: m }) => ({ initiator: e(t, { fields: [f.initiatorId], references: [t.id], relationName: "initiator" }), receiver: e(t, { fields: [f.receiverId], references: [t.id], relationName: "receiver" }), items: m(I) })), W = relations(I, ({ one: e }) => ({ trade: e(f, { fields: [I.tradeId], references: [f.id] }), item: e(n, { fields: [I.itemId], references: [n.id] }), user: e(t, { fields: [I.userId], references: [t.id] }), userSpecifiedRarity: e(_, { fields: [I.userSpecifiedRarityId], references: [_.id] }) })), X = relations(T, ({ one: e }) => ({ user: e(t, { fields: [T.userId], references: [t.id] }) })), Y = relations(A, ({ one: e }) => ({ user: e(t, { fields: [A.userId], references: [t.id] }) })), Z = relations(w, ({ one: e }) => ({ user: e(t, { fields: [w.userId], references: [t.id] }), game: e(a, { fields: [w.gameId], references: [a.id] }), category: e(y, { fields: [w.categoryId], references: [y.id] }) })), ee = relations(q, ({ one: e }) => ({ item: e(n, { fields: [q.itemId], references: [n.id] }) })), k = Object.freeze(Object.defineProperty({ __proto__: null, account: D, accountRelations: L, categories: y, categoriesRelations: j, coinCashouts: A, coinCashoutsRelations: Y, coinPurchases: T, coinPurchasesRelations: X, games: a, gamesRelations: M, items: n, itemsRelations: V, listings: p, listingsRelations: Q, priceHistory: q, priceHistoryRelations: ee, rarityTypes: _, rarityTypesRelations: B, searchHistory: w, searchHistoryRelations: Z, session: R, sessionRelations: H, timestamps: d, tradeItems: I, tradeItemsRelations: W, trades: f, tradesRelations: J, transactions: g, transactionsRelations: $, user: t, userFollows: v, userFollowsRelations: G, userRelations: U, userReviews: N, userReviewsRelations: F, verification: O }, Symbol.toStringTag, { value: "Module" }));
if (!process.env.DATABASE_URL) throw new Error("DATABASE_URL is not defined");
const ie = drizzle(process.env.DATABASE_URL, { schema: k }), b = betterAuth({ database: drizzleAdapter(ie, { provider: "sqlite", schema: k }), user: { modelName: "user", additionalFields: { userName: { type: "string", nullable: false, unique: true, required: true }, name: { type: "string", nullable: true, required: false }, bio: { type: "string", nullable: true, required: false }, totalCoins: { type: "number", nullable: false, required: false, input: false }, reputationScore: { type: "number", nullable: false, required: false, input: false }, followersCount: { type: "number", nullable: false, required: false, input: false }, followingCount: { type: "number", nullable: false, required: false, input: false }, tradeCount: { type: "number", nullable: false, required: false, input: false } } }, emailAndPassword: { enabled: true }, socialProviders: { google: { enabled: true, clientId: process.env.GOOGLE_CLIENT_ID || "", clientSecret: process.env.GOOGLE_CLIENT_SECRET || "" } } }), ue = x("/api/auth/$")({ GET: ({ request: e }) => b.handler(e), POST: ({ request: e }) => b.handler(e) });

export { ue as APIRoute };
//# sourceMappingURL=_.mjs.map
