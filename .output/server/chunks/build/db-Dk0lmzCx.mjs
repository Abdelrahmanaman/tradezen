import { drizzle } from 'drizzle-orm/node-postgres';
import { pgTable, timestamp, text, boolean, integer, serial, index, real, jsonb } from 'drizzle-orm/pg-core';
import { relations, sql } from 'drizzle-orm';

const n = { updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().default(sql`now()`), createdAt: timestamp("created_at", { withTimezone: true }).notNull().default(sql`now()`) }, t = pgTable("user", { id: text("id").primaryKey(), name: text("name"), email: text("email").notNull().unique(), emailVerified: boolean("email_verified").notNull(), image: text("image"), userName: text("user_name").notNull().unique(), totalCoins: integer("total_coins").notNull().default(0), paypalEmail: text("paypal_email"), preferredPaymentMethod: text("preferred_payment_method"), bio: text("bio"), reputationScore: real("reputation_score").default(0), followersCount: integer("followers_count").notNull().default(0), followingCount: integer("following_count").notNull().default(0), tradeCount: integer("trade_count").notNull().default(0), ...n }), R = pgTable("session", { id: text("id").primaryKey(), expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(), token: text("token").notNull().unique(), ipAddress: text("ip_address"), userAgent: text("user_agent"), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), ...n }), D = pgTable("account", { id: text("id").primaryKey(), accountId: text("account_id").notNull(), providerId: text("provider_id").notNull(), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), accessToken: text("access_token"), refreshToken: text("refresh_token"), idToken: text("id_token"), accessTokenExpiresAt: timestamp("access_token_expires_at", { withTimezone: true }), refreshTokenExpiresAt: timestamp("refresh_token_expires_at", { withTimezone: true }), scope: text("scope"), password: text("password"), ...n }), S = pgTable("verification", { id: text("id").primaryKey(), identifier: text("identifier").notNull(), value: text("value").notNull(), expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(), ...n }), a = pgTable("games", { id: serial("id").primaryKey(), name: text("name").notNull().unique(), description: text("description"), logoUrl: text("logo_url"), isActive: boolean("is_active").default(true), sortOrder: integer("sort_order").default(0), ...n }), y = pgTable("categories", { id: serial("id").primaryKey(), gameId: integer("game_id").notNull().references(() => a.id, { onDelete: "cascade" }), name: text("name").notNull(), description: text("description"), sortOrder: integer("sort_order").default(0), ...n }, (e) => [index("idx_categories_game_id").on(e.gameId)]), _ = pgTable("rarity_types", { id: serial("id").primaryKey(), gameId: integer("game_id").notNull().references(() => a.id, { onDelete: "cascade" }), name: text("name").notNull(), displayName: text("display_name"), colorHex: text("color_hex"), sortOrder: integer("sort_order").default(0), ...n }, (e) => [index("idx_rarity_types_game_id").on(e.gameId), index("idx_rarity_types_unique").on(e.gameId, e.name)]), d = pgTable("items", { id: serial("id").primaryKey(), gameId: integer("game_id").notNull().references(() => a.id, { onDelete: "cascade" }), categoryId: integer("category_id").notNull().references(() => y.id, { onDelete: "cascade" }), name: text("name").notNull(), description: text("description"), imageUrl: text("image_url").notNull(), suggestedPrice: integer("suggested_price"), isActive: boolean("is_active").default(true), slug: text("slug").notNull().unique(), metadata: jsonb("metadata"), rarityTypeId: integer("rarity_type_id").references(() => _.id, { onDelete: "set null" }), ...n }, (e) => [index("idx_items_game_id").on(e.gameId), index("idx_items_category_id").on(e.categoryId), index("idx_items_name").on(e.name), index("idx_items_rarity_type_id").on(e.rarityTypeId)]), p = pgTable("listings", { id: serial("id").primaryKey(), sellerId: text("seller_id").notNull().references(() => t.id, { onDelete: "cascade" }), itemId: integer("item_id").notNull().references(() => d.id, { onDelete: "cascade" }), price: integer("price").notNull(), quantity: integer("quantity").default(1), age: text("age"), lookingFor: text("looking_for").array(), listingRarityId: integer("listing_rarity_id").references(() => _.id, { onDelete: "set null" }), status: text("status").notNull().default("active"), featured: boolean("featured").default(false), slug: text("slug").notNull(), expiresAt: timestamp("expires_at", { withTimezone: true }), metadata: jsonb("metadata"), ...n }, (e) => [index("idx_listings_status").on(e.status), index("idx_listings_seller_id").on(e.sellerId), index("idx_listings_item_id").on(e.itemId), index("idx_listings_listing_rarity_id").on(e.listingRarityId), index("idx_listings_featured").on(e.featured)]), g = pgTable("transactions", { id: serial("id").primaryKey(), listingId: integer("listing_id").references(() => p.id, { onDelete: "set null" }), buyerId: text("buyer_id").notNull().references(() => t.id, { onDelete: "restrict" }), sellerId: text("seller_id").notNull().references(() => t.id, { onDelete: "restrict" }), itemId: integer("item_id").notNull().references(() => d.id, { onDelete: "restrict" }), price: integer("price").notNull(), quantity: integer("quantity").notNull().default(1), transactionType: text("transaction_type").notNull(), timestamp: timestamp("timestamp").notNull().default(sql`now()`), ...n }, (e) => [index("idx_transactions_buyer_id").on(e.buyerId), index("idx_transactions_seller_id").on(e.sellerId)]), m = pgTable("trades", { id: serial("id").primaryKey(), initiatorId: text("initiator_id").notNull().references(() => t.id, { onDelete: "cascade" }), receiverId: text("receiver_id").notNull().references(() => t.id, { onDelete: "cascade" }), initiatorCoinsOffered: integer("initiator_coins_offered").default(0), receiverCoinsRequested: integer("receiver_coins_requested").default(0), status: text("status").notNull().default("pending"), message: text("message"), completedAt: timestamp("completed_at", { withTimezone: true }), ...n }, (e) => [index("idx_trades_initiator_id").on(e.initiatorId), index("idx_trades_receiver_id").on(e.receiverId), index("idx_trades_status").on(e.status)]), I = pgTable("trade_items", { id: serial("id").primaryKey(), tradeId: integer("trade_id").notNull().references(() => m.id, { onDelete: "cascade" }), itemId: integer("item_id").notNull().references(() => d.id, { onDelete: "restrict" }), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), quantity: integer("quantity").default(1), userSpecifiedRarityId: integer("user_specified_rarity_id").references(() => _.id, { onDelete: "set null" }), metadata: jsonb("metadata"), ...n }, (e) => [index("idx_trade_items_trade_id").on(e.tradeId), index("idx_trade_items_user_id").on(e.userId), index("idx_trade_items_rarity_id").on(e.userSpecifiedRarityId)]), T = pgTable("coin_purchases", { id: serial("id").primaryKey(), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), coinsAmount: integer("coins_amount").notNull(), cashAmount: real("cash_amount").notNull(), paymentMethod: text("payment_method").notNull(), paymentReference: text("payment_reference"), status: text("status").notNull().default("completed"), timestamp: timestamp("timestamp").notNull().default(sql`now()`), ...n }, (e) => [index("idx_coin_purchases_user_id").on(e.userId)]), A = pgTable("coin_cashouts", { id: serial("id").primaryKey(), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), coinsAmount: integer("coins_amount").notNull(), cashAmount: real("cash_amount").notNull(), paymentMethod: text("payment_method").notNull(), paymentDetails: text("payment_details"), status: text("status").notNull().default("pending"), timestamp: timestamp("timestamp").notNull().default(sql`now()`), processedAt: timestamp("processed_at", { withTimezone: true }), notes: text("notes"), ...n }, (e) => [index("idx_coin_cashouts_user_id").on(e.userId), index("idx_coin_cashouts_status").on(e.status)]), w = pgTable("search_history", { id: serial("id").primaryKey(), userId: text("user_id").notNull().references(() => t.id, { onDelete: "cascade" }), searchQuery: text("search_query").notNull(), gameId: integer("game_id").references(() => a.id, { onDelete: "set null" }), categoryId: integer("category_id").references(() => y.id, { onDelete: "set null" }), timestamp: timestamp("timestamp").notNull().default(sql`now()`), ...n }, (e) => [index("idx_search_history_user_id").on(e.userId)]), q = pgTable("price_history", { id: serial("id").primaryKey(), itemId: integer("item_id").notNull().references(() => d.id, { onDelete: "cascade" }), averagePrice: integer("average_price").notNull(), volume: integer("volume").notNull(), date: text("date").notNull(), ...n }, (e) => [index("idx_price_history_item_id").on(e.itemId), index("idx_price_history_date").on(e.date)]), N = pgTable("user_reviews", { id: serial("id").primaryKey(), reviewerId: text("reviewer_id").notNull().references(() => t.id, { onDelete: "cascade" }), targetUserId: text("target_user_id").notNull().references(() => t.id, { onDelete: "cascade" }), tradeId: integer("trade_id").references(() => m.id, { onDelete: "set null" }), rating: integer("rating").notNull(), comment: text("comment"), isVisible: boolean("is_visible").notNull().default(true), ...n }, (e) => [index("idx_user_reviews_reviewer_id").on(e.reviewerId), index("idx_user_reviews_target_user_id").on(e.targetUserId), index("idx_user_reviews_unique_per_trade").on(e.reviewerId, e.targetUserId, e.tradeId)]), v = pgTable("user_follows", { id: serial("id").primaryKey(), followerId: text("follower_id").notNull().references(() => t.id, { onDelete: "cascade" }), followingId: text("following_id").notNull().references(() => t.id, { onDelete: "cascade" }), ...n }, (e) => [index("idx_user_follows_unique").on(e.followerId, e.followingId), index("idx_user_follows_follower_id").on(e.followerId), index("idx_user_follows_following_id").on(e.followingId)]), U = relations(t, ({ many: e }) => ({ sessions: e(R), accounts: e(D), listings: e(p, { relationName: "seller" }), buyerTransactions: e(g, { relationName: "buyer" }), sellerTransactions: e(g, { relationName: "seller" }), initiatedTrades: e(m, { relationName: "initiator" }), receivedTrades: e(m, { relationName: "receiver" }), tradeItems: e(I), coinPurchases: e(T), coinCashouts: e(A), searchHistory: e(w), receivedReviews: e(N, { relationName: "receivedReviews" }), givenReviews: e(N, { relationName: "givenReviews" }), followers: e(v, { relationName: "followers" }), following: e(v, { relationName: "following" }) })), C = relations(R, ({ one: e }) => ({ user: e(t, { fields: [R.userId], references: [t.id] }) })), E = relations(D, ({ one: e }) => ({ user: e(t, { fields: [D.userId], references: [t.id] }) })), H = relations(N, ({ one: e }) => ({ reviewer: e(t, { fields: [N.reviewerId], references: [t.id], relationName: "givenReviews" }), targetUser: e(t, { fields: [N.targetUserId], references: [t.id], relationName: "receivedReviews" }), trade: e(m, { fields: [N.tradeId], references: [m.id] }) })), P = relations(v, ({ one: e }) => ({ follower: e(t, { fields: [v.followerId], references: [t.id], relationName: "following" }), following: e(t, { fields: [v.followingId], references: [t.id], relationName: "followers" }) })), O = relations(a, ({ many: e }) => ({ categories: e(y), items: e(d), rarityTypes: e(_) })), M = relations(y, ({ one: e, many: f }) => ({ game: e(a, { fields: [y.gameId], references: [a.id] }), items: f(d) })), j = relations(_, ({ one: e, many: f }) => ({ game: e(a, { fields: [_.gameId], references: [a.id] }), listings: f(p, { relationName: "listingRarity" }) })), B = relations(d, ({ one: e, many: f }) => ({ game: e(a, { fields: [d.gameId], references: [a.id] }), category: e(y, { fields: [d.categoryId], references: [y.id] }), listings: f(p), transactions: f(g), priceHistory: f(q), rarityType: e(_, { fields: [d.rarityTypeId], references: [_.id] }) })), F = relations(p, ({ one: e, many: f }) => ({ seller: e(t, { fields: [p.sellerId], references: [t.id], relationName: "seller" }), item: e(d, { fields: [p.itemId], references: [d.id] }), listingRarity: e(_, { fields: [p.listingRarityId], references: [_.id], relationName: "listingRarity" }), transactions: f(g) })), L = relations(g, ({ one: e }) => ({ buyer: e(t, { fields: [g.buyerId], references: [t.id], relationName: "buyer" }), seller: e(t, { fields: [g.sellerId], references: [t.id], relationName: "seller" }), listing: e(p, { fields: [g.listingId], references: [p.id] }), item: e(d, { fields: [g.itemId], references: [d.id] }) })), V = relations(m, ({ one: e, many: f }) => ({ initiator: e(t, { fields: [m.initiatorId], references: [t.id], relationName: "initiator" }), receiver: e(t, { fields: [m.receiverId], references: [t.id], relationName: "receiver" }), items: f(I) })), Q = relations(I, ({ one: e }) => ({ trade: e(m, { fields: [I.tradeId], references: [m.id] }), item: e(d, { fields: [I.itemId], references: [d.id] }), user: e(t, { fields: [I.userId], references: [t.id] }), userSpecifiedRarity: e(_, { fields: [I.userSpecifiedRarityId], references: [_.id] }) })), G = relations(T, ({ one: e }) => ({ user: e(t, { fields: [T.userId], references: [t.id] }) })), J = relations(A, ({ one: e }) => ({ user: e(t, { fields: [A.userId], references: [t.id] }) })), W = relations(w, ({ one: e }) => ({ user: e(t, { fields: [w.userId], references: [t.id] }), game: e(a, { fields: [w.gameId], references: [a.id] }), category: e(y, { fields: [w.categoryId], references: [y.id] }) })), X = relations(q, ({ one: e }) => ({ item: e(d, { fields: [q.itemId], references: [d.id] }) })), Y = Object.freeze(Object.defineProperty({ __proto__: null, account: D, accountRelations: E, categories: y, categoriesRelations: M, coinCashouts: A, coinCashoutsRelations: J, coinPurchases: T, coinPurchasesRelations: G, games: a, gamesRelations: O, items: d, itemsRelations: B, listings: p, listingsRelations: F, priceHistory: q, priceHistoryRelations: X, rarityTypes: _, rarityTypesRelations: j, searchHistory: w, searchHistoryRelations: W, session: R, sessionRelations: C, timestamps: n, tradeItems: I, tradeItemsRelations: Q, trades: m, tradesRelations: V, transactions: g, transactionsRelations: L, user: t, userFollows: v, userFollowsRelations: P, userRelations: U, userReviews: N, userReviewsRelations: H, verification: S }, Symbol.toStringTag, { value: "Module" }));
if (!process.env.DATABASE_URL) throw new Error("DATABASE_URL is not defined");
const ie = drizzle(process.env.DATABASE_URL, { schema: Y });

export { Y, ie as i, p };
//# sourceMappingURL=db-Dk0lmzCx.mjs.map
